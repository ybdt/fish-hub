## 0x00 漏洞复现
环境搭建及漏洞复现见：https://github.com/ybdt/exp-hub/tree/master/2021_02_28_VMware%20vCenter%20Server%E6%9C%AA%E6%8E%88%E6%9D%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0

## 0x01 静态分析
读懂下面两段代码，即可理解漏洞产生原理
```
@RequestMapping(
        value = {"/uploadova"},
        method = {RequestMethod.POST}
    )
    public void uploadOvaFile(@RequestParam(value = "uploadFile", required = true) CommonsMultipartFile uploadFile, HttpServletResponse response) throws Exception {
        logger.info("Entering uploadOvaFile api");
        int code = uploadFile.isEmpty() ? 400 : 200;
        PrintWriter wr = null;
...
        response.setStatus(code);
        String returnStatus = "SUCCESS";
        if (!uploadFile.isEmpty()) {
            try {
                logger.info("Downloading OVA file has been started");
                logger.info( "Size of the file received  : " + uploadFile.getSize() );
                InputStream inputStream = uploadFile.getInputStream();
                File dir = new File("/tmp/unicorn_ova_dir");
                if (!dir.exists()) {
                    dir.mkdirs();
                } else {
                    String[] entries = dir.list();
                    String[] var9 = entries;
                    int var10 = entries.length;

                    for(int var11 = 0; var11 < var10; ++var11) {
                        String entry = var9[var11];
                        File currentFile = new File(dir.getPath(), entry);
                        currentFile.delete();
                    }

                    logger.info("Successfully cleaned : /tmp/unicorn_ova_dir");
                }

                TarArchiveInputStream in = new TarArchiveInputStream(inputStream);
                TarArchiveEntry entry = in.getNextTarEntry();
                ArrayList result = new ArrayList();
```

基本逻辑如下：  
@RequestMapping是类或方法的修饰器，当修饰方法时，指明方法在响应请求时使用指定的路径作为跟路径，以及使用指定的方法上传  
先检查上载文件是否为空，为空则将返回码定义为400，不为空将返回码定义为200  
当上载内容不为空的时候，先读取上载的内容到输入流，然后清除/tmp/unicorn_ova_dir下的所有文件，最后提示清除完成  
使用之前读取的输入流创建TarArchive输入流，读取tar压缩文件中的第一个文件
```
 while(entry != null) {
                    if (entry.isDirectory()) {
                        entry = in.getNextTarEntry();
                    } else {
                        File curfile = new File("/tmp/unicorn_ova_dir", entry.getName());
                        File parent = curfile.getParentFile();
                        if (!parent.exists()) {
                            parent.mkdirs();
```
基本逻辑如下：  
判断第一项是否为空，不为空则进入循环  
如果第一项是目录，则跳过第一项  
当第一项是文件时，使用/tmp/unicorn_ova_dir结合第一项的名字，作为新的文件路径，此处则为漏洞产生的关键点，由于未进行过滤，如果文件名存在../../可导致目录遍历漏洞，再结合之前读取第一项的内容，赋值给新的文件路径，可用于RCE

具体的RCE方式，原作者提到，Windows下通过寻找可写入的目录，来写入Webshell，Linux下通过写入authorized_keys，实现vsphere-ui身份的远程登录

## 0x02 动态分析
无

## 0x03 参考链接
http://noahblog.360.cn/vcenter-6-5-7-0-rce-lou-dong-fen-xi/?continueFlag=542f9390afb74a1758303feb14144afc
https://swarm.ptsecurity.com/unauth-rce-vmware/
